<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS中的内存管理 | Vic的博客</title>
    <meta name="description" content="Vic,preson,日常开发记录,语言准备,Edmonton">
    <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="icon" href="./images/logo.gif">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="blog/assets/css/0.styles.a6bd5197.css" as="style"><link rel="preload" href="blog/assets/js/app.24b47bb2.js" as="script"><link rel="preload" href="blog/assets/js/58.4128750e.js" as="script"><link rel="preload" href="blog/assets/js/8.7f11c8af.js" as="script"><link rel="prefetch" href="blog/assets/js/10.b9735447.js"><link rel="prefetch" href="blog/assets/js/11.0d6f5dc9.js"><link rel="prefetch" href="blog/assets/js/12.e4d845cf.js"><link rel="prefetch" href="blog/assets/js/13.712197c9.js"><link rel="prefetch" href="blog/assets/js/14.b14e6c26.js"><link rel="prefetch" href="blog/assets/js/15.bda3ed3b.js"><link rel="prefetch" href="blog/assets/js/16.c2cc75dd.js"><link rel="prefetch" href="blog/assets/js/17.abe296f5.js"><link rel="prefetch" href="blog/assets/js/18.a2542d1a.js"><link rel="prefetch" href="blog/assets/js/19.b1235c9b.js"><link rel="prefetch" href="blog/assets/js/2.51a4babd.js"><link rel="prefetch" href="blog/assets/js/20.4282b08d.js"><link rel="prefetch" href="blog/assets/js/21.ef90e696.js"><link rel="prefetch" href="blog/assets/js/22.4b9752d2.js"><link rel="prefetch" href="blog/assets/js/23.7965b2e8.js"><link rel="prefetch" href="blog/assets/js/24.7144c9af.js"><link rel="prefetch" href="blog/assets/js/25.346cb919.js"><link rel="prefetch" href="blog/assets/js/26.b56ede3d.js"><link rel="prefetch" href="blog/assets/js/27.48d371f7.js"><link rel="prefetch" href="blog/assets/js/28.3e09139b.js"><link rel="prefetch" href="blog/assets/js/29.1aa5a3c0.js"><link rel="prefetch" href="blog/assets/js/3.6537c304.js"><link rel="prefetch" href="blog/assets/js/30.b267c7a0.js"><link rel="prefetch" href="blog/assets/js/31.9c5de5f0.js"><link rel="prefetch" href="blog/assets/js/32.956deabd.js"><link rel="prefetch" href="blog/assets/js/33.9113e4c5.js"><link rel="prefetch" href="blog/assets/js/34.b351426b.js"><link rel="prefetch" href="blog/assets/js/35.4c7963f5.js"><link rel="prefetch" href="blog/assets/js/36.c4ffc5cf.js"><link rel="prefetch" href="blog/assets/js/37.aadfeccc.js"><link rel="prefetch" href="blog/assets/js/38.ff81dbec.js"><link rel="prefetch" href="blog/assets/js/39.d0f4152f.js"><link rel="prefetch" href="blog/assets/js/4.2921848a.js"><link rel="prefetch" href="blog/assets/js/40.022ae3a6.js"><link rel="prefetch" href="blog/assets/js/41.25d70280.js"><link rel="prefetch" href="blog/assets/js/42.3aa133aa.js"><link rel="prefetch" href="blog/assets/js/43.25b92b3a.js"><link rel="prefetch" href="blog/assets/js/44.27d9059e.js"><link rel="prefetch" href="blog/assets/js/45.2da90f94.js"><link rel="prefetch" href="blog/assets/js/46.13b2b1b8.js"><link rel="prefetch" href="blog/assets/js/47.5b5d9388.js"><link rel="prefetch" href="blog/assets/js/48.8a5dcf3e.js"><link rel="prefetch" href="blog/assets/js/49.58b0bfdd.js"><link rel="prefetch" href="blog/assets/js/5.db4be22f.js"><link rel="prefetch" href="blog/assets/js/50.393cc386.js"><link rel="prefetch" href="blog/assets/js/51.3df91732.js"><link rel="prefetch" href="blog/assets/js/52.8784d899.js"><link rel="prefetch" href="blog/assets/js/53.12b9e9a7.js"><link rel="prefetch" href="blog/assets/js/54.fa254d1d.js"><link rel="prefetch" href="blog/assets/js/55.ff70833f.js"><link rel="prefetch" href="blog/assets/js/56.0f49028f.js"><link rel="prefetch" href="blog/assets/js/57.1059462c.js"><link rel="prefetch" href="blog/assets/js/59.b0325ec7.js"><link rel="prefetch" href="blog/assets/js/6.52af3c62.js"><link rel="prefetch" href="blog/assets/js/60.0b9439a1.js"><link rel="prefetch" href="blog/assets/js/61.2c5b15a1.js"><link rel="prefetch" href="blog/assets/js/62.6eb1a621.js"><link rel="prefetch" href="blog/assets/js/63.da11ee8f.js"><link rel="prefetch" href="blog/assets/js/64.849a2525.js"><link rel="prefetch" href="blog/assets/js/65.0ee0faaf.js"><link rel="prefetch" href="blog/assets/js/66.cb34d58f.js"><link rel="prefetch" href="blog/assets/js/67.d54b422a.js"><link rel="prefetch" href="blog/assets/js/68.7d269019.js"><link rel="prefetch" href="blog/assets/js/69.84da84e7.js"><link rel="prefetch" href="blog/assets/js/7.78906fc9.js"><link rel="prefetch" href="blog/assets/js/70.2b9bfcbe.js"><link rel="prefetch" href="blog/assets/js/71.406b74b3.js"><link rel="prefetch" href="blog/assets/js/72.480ff203.js"><link rel="prefetch" href="blog/assets/js/73.dbbac51a.js"><link rel="prefetch" href="blog/assets/js/74.f833cba4.js"><link rel="prefetch" href="blog/assets/js/75.afd6b113.js"><link rel="prefetch" href="blog/assets/js/76.43da6b21.js"><link rel="prefetch" href="blog/assets/js/77.513b6b14.js"><link rel="prefetch" href="blog/assets/js/78.2ac7f15b.js"><link rel="prefetch" href="blog/assets/js/79.6d81e646.js"><link rel="prefetch" href="blog/assets/js/80.228826e4.js"><link rel="prefetch" href="blog/assets/js/81.a08895c6.js"><link rel="prefetch" href="blog/assets/js/82.ac414c3c.js"><link rel="prefetch" href="blog/assets/js/83.49a71d38.js"><link rel="prefetch" href="blog/assets/js/84.a481e438.js"><link rel="prefetch" href="blog/assets/js/85.8d623689.js"><link rel="prefetch" href="blog/assets/js/86.994129b9.js"><link rel="prefetch" href="blog/assets/js/87.87c6db43.js"><link rel="prefetch" href="blog/assets/js/88.5689a53a.js"><link rel="prefetch" href="blog/assets/js/89.e7428311.js"><link rel="prefetch" href="blog/assets/js/9.ef6f5b3b.js"><link rel="prefetch" href="blog/assets/js/90.497d587a.js"><link rel="prefetch" href="blog/assets/js/91.dee61449.js"><link rel="prefetch" href="blog/assets/js/92.7351c800.js"><link rel="prefetch" href="blog/assets/js/93.aa08fafd.js">
    <link rel="stylesheet" href="blog/assets/css/0.styles.a6bd5197.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Vic的博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">主页</a></div><div class="nav-item"><a href="/blog/nodeJS/koa.html" class="nav-link">Node.js</a></div><div class="nav-item"><a href="/blog/ui/sass.html" class="nav-link">UI</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">javascript</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/basic/array.html" class="nav-link">常用功能记录</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/upper/eventBus.html" class="nav-link">js进阶</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/algorithm/1.html" class="nav-link">常用算法</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/extend/code.html" class="nav-link">拓展阅读</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">source Code</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/source/vue/compiler.html" class="nav-link">Vue.js</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">主页</a></div><div class="nav-item"><a href="/blog/nodeJS/koa.html" class="nav-link">Node.js</a></div><div class="nav-item"><a href="/blog/ui/sass.html" class="nav-link">UI</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">javascript</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/basic/array.html" class="nav-link">常用功能记录</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/upper/eventBus.html" class="nav-link">js进阶</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/algorithm/1.html" class="nav-link">常用算法</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/extend/code.html" class="nav-link">拓展阅读</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">source Code</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/source/vue/compiler.html" class="nav-link">Vue.js</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/javascript/extend/code.html" class="sidebar-link">到底如何写一个优雅的函数？</a></li><li><a href="/blog/javascript/extend/jsonStringify.html" class="sidebar-link">Javascript中JSON隐藏的特性</a></li><li><a href="/blog/javascript/extend/ES2016.html" class="sidebar-link">ECMAScript历代版本特性 - ES7(2016)</a></li><li><a href="/blog/javascript/extend/ES2017.html" class="sidebar-link">ECMAScript历代版本特性 - ES8(2017)</a></li><li><a href="/blog/javascript/extend/ES2018.html" class="sidebar-link">ECMAScript历代版本特性 - ES9(2018)</a></li><li><a href="/blog/javascript/extend/ES2019.html" class="sidebar-link">ECMAScript历代版本特性 - ES10(2019)</a></li><li><a href="/blog/javascript/extend/ES2020.html" class="sidebar-link">ECMAScript历代版本特性 - ES11(2020)</a></li><li><a href="/blog/javascript/extend/ES2021.html" class="sidebar-link">ECMAScript历代版本特性 - ES12(2021)</a></li><li><a href="/blog/javascript/extend/ES2022.html" class="sidebar-link">ECMAScript历代版本特性 - ES13(2022)</a></li><li><a href="/blog/javascript/extend/fetch.html" class="sidebar-link">Fetch</a></li><li><a href="/blog/javascript/extend/memory.html" aria-current="page" class="active sidebar-link">JS中的内存管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/javascript/extend/memory.html#内存生命周期" class="sidebar-link">内存生命周期</a></li><li class="sidebar-sub-header"><a href="/blog/javascript/extend/memory.html#js-的内存使用" class="sidebar-link">JS 的内存使用</a></li><li class="sidebar-sub-header"><a href="/blog/javascript/extend/memory.html#js-的内存回收" class="sidebar-link">JS 的内存回收</a></li><li class="sidebar-sub-header"><a href="/blog/javascript/extend/memory.html#标记清除算法" class="sidebar-link">标记清除算法</a></li><li class="sidebar-sub-header"><a href="/blog/javascript/extend/memory.html#内存泄漏" class="sidebar-link">内存泄漏</a></li><li class="sidebar-sub-header"><a href="/blog/javascript/extend/memory.html#常见的内存泄露案例" class="sidebar-link">常见的内存泄露案例</a></li><li class="sidebar-sub-header"><a href="/blog/javascript/extend/memory.html#排查javascript内存泄漏" class="sidebar-link">排查Javascript内存泄漏</a></li></ul></li><li><a href="/blog/javascript/extend/monitoring.html" class="sidebar-link">前端监控</a></li><li><a href="/blog/javascript/extend/http.html" class="sidebar-link">http报文结构是怎样的?</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="js中的内存管理"><a href="#js中的内存管理" class="header-anchor">#</a> JS中的内存管理</h1> <p>像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()用于分配内存和释放内存。 而对于JavaScript来说，会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放内存，这个自动释放内存的过程称为垃圾回收。 因为自动垃圾回收机制的存在，让大多Javascript开发者感觉他们可以不关心内存管理，所以会在一些情况下导致内存泄漏。</p> <h2 id="内存生命周期"><a href="#内存生命周期" class="header-anchor">#</a> 内存生命周期</h2> <img src="https://www.vicray.cn/images/upper/memort_life_cycle.jpg" alt="生命周期">
JS 环境中分配的内存有如下声明周期：
<ul><li>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存</li> <li>内存使用：即读写内存，也就是使用变量、函数等</li> <li>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存
JS 的内存分配
为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// 给数值变量分配内存</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;azerty&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 给字符串分配内存</span>

<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 给对象及其包含的值分配内存</span>

<span class="token comment">// 给数组及其包含的值分配内存（就像对象一样）</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">&quot;abra&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 给函数（可调用的对象）分配内存</span>

<span class="token comment">// 函数表达式也能分配一个对象</span>
someElement<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  someElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">'blue'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>有些函数调用结果是分配对象内存：</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配一个 Date 对象</span>

<span class="token keyword">var</span> e <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配一个 DOM 元素</span>
有些方法分配新变量或者新对象：

<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;azerty&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s2 是一个新的字符串</span>
<span class="token comment">// 因为字符串是不变量，</span>
<span class="token comment">// JavaScript 可能决定不分配内存，</span>
<span class="token comment">// 只是存储了 [0-3] 的范围。</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;ouais ouais&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;nan nan&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;generation&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;nan nan&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a3 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 新数组有四个元素，是 a 连接 a2 的结果</span>

</code></pre></div><h2 id="js-的内存使用"><a href="#js-的内存使用" class="header-anchor">#</a> JS 的内存使用</h2> <p>使用值的过程实际上是对分配内存进行读取与写入的操作。 读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 分配内存</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对内存的使用</span>
</code></pre></div><h2 id="js-的内存回收"><a href="#js-的内存回收" class="header-anchor">#</a> JS 的<strong>内存回收</strong></h2> <p>JS 有自动垃圾回收机制，那么这个自动垃圾回收机制的原理是什么呢？ 其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。</p> <p>大多数内存管理的问题都在这个阶段。 在这里最艰难的任务是找到不再需要使用的变量。</p> <p>不再需要使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在， 当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。</p> <p>全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。</p> <p>因为自动垃圾回收机制的存在，开发人员可以不关心也不注意内存释放的有关问题，但对无用内存的释放这件事是客观存在的。 不幸的是，即使不考虑垃圾回收对性能的影响，目前最新的垃圾回收算法，也无法智能回收所有的极端情况。</p> <p>接下来我们来探究一下 JS 垃圾回收的机制。</p> <p>垃圾回收
引用
垃圾回收算法主要依赖于引用的概念。</p> <p>在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。</p> <p>例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p> <p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。</p> <p>引用计数垃圾收集
这是最初级的垃圾回收算法。</p> <p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。 如果没有其他对象指向它了，说明该对象已经不再需了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> 
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">b</span><span class="token operator">:</span><span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span>
<span class="token comment">// 很显然，没有一个可以被垃圾收集</span>

<span class="token keyword">var</span> o2 <span class="token operator">=</span> o<span class="token punctuation">;</span> <span class="token comment">// o2变量是第二个对“这个对象”的引用</span>

o <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// 现在，“这个对象”的原始引用o被o2替换了</span>

<span class="token keyword">var</span> oa <span class="token operator">=</span> o2<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 引用“这个对象”的a属性</span>
<span class="token comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span>

o2 <span class="token operator">=</span> <span class="token string">&quot;yo&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 最初的对象现在已经是零引用了</span>
           <span class="token comment">// 他可以被垃圾回收了</span>
           <span class="token comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span>

oa <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// a属性的那个对象现在也是零引用了</span>
           <span class="token comment">// 它可以被垃圾回收了</span>
</code></pre></div><p>由上面可以看出，引用计数算法是个简单有效的算法。但它却存在一个致命的问题：<strong>循环引用</strong>。
如果两个对象相互引用，尽管他们已不再使用，垃圾回收不会进行回收，导致<strong>内存泄露</strong>。
来看一个循环引用的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>a <span class="token operator">=</span> o2<span class="token punctuation">;</span> <span class="token comment">// o 引用 o2</span>
  o2<span class="token punctuation">.</span>a <span class="token operator">=</span> o<span class="token punctuation">;</span> <span class="token comment">// o2 引用 o  这里</span>

  <span class="token keyword">return</span> <span class="token string">&quot;azerty&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面我们申明了一个函数 f ，其中包含两个相互引用的对象。 在调用函数结束后，对象 o1 和 o2 实际上已离开函数范围，因此不再需要了。 但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收，内存泄露不可避免了。</p> <p>再来看一个实际的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;div&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>上面这种JS写法再普通不过了，创建一个DOM元素并绑定一个点击事件。 此时变量 div 有事件处理函数的引用，同时事件处理函数也有div的引用！（div变量可在函数内被访问）。 一个循序引用出现了，按上面所讲的算法，该部分内存无可避免的泄露了。</p> <p>为了解决循环引用造成的问题，现代浏览器通过使用<strong>标记清除算法</strong>来实现垃圾回收。</p> <h2 id="标记清除算法"><a href="#标记清除算法" class="header-anchor">#</a> 标记清除算法</h2> <p>标记清除算法将“<strong>不再使用的对象</strong>”定义为“<strong>无法达到的对象</strong>”。 简单来说，就是从根部（在JS中就是全局对象）出发定时扫描<strong>内存中的对象</strong>。 凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</p> <p>从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。 但反之未必成立。</p> <p>工作流程：
1.垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。
2.从根部出发将能触及到的对象的标记清除。
3.那些还存在标记的变量被视为准备删除的变量。
4.最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。</p> <img src="https://www.vicray.cn/images/upper/sweep.gif"> <p>循环引用不再是问题了
再看之前循环引用的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>a <span class="token operator">=</span> o2<span class="token punctuation">;</span> <span class="token comment">// o 引用 o2</span>
  o2<span class="token punctuation">.</span>a <span class="token operator">=</span> o<span class="token punctuation">;</span> <span class="token comment">// o2 引用 o</span>

  <span class="token keyword">return</span> <span class="token string">&quot;azerty&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>函数调用返回之后，两个循环引用的对象在垃圾收集时从全局对象出发无法再获取他们的引用。 因此，他们将会被垃圾回收器回收。</p> <h2 id="内存泄漏"><a href="#内存泄漏" class="header-anchor">#</a> 内存泄漏</h2> <p>什么是内存泄漏?
程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。</p> <p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。 否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p> <p>本质上讲,<code>内存泄漏就是由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费</code>。</p> <p>内存泄漏的识别方法
经验法则是，<code>如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。 这就要求实时查看内存的占用情况</code>。</p> <p>在 Chrome 浏览器中，我们可以这样查看内存占用情况
打开开发者工具，选择 <strong>Performance</strong>面板
在顶部勾选 <strong>Memory</strong>
点击左上角的 <strong>record</strong>按钮
在页面上进行各种操作，模拟用户的使用情况
一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况
来看一张效果图：
<img src="https://www.vicray.cn/images/upper/memory-info.png" alt="效果图"></p> <p>我们有两种方式来判定当前是否有内存泄漏：</p> <ul><li>多次快照后，比较每次快照中内存的占用情况，如果呈上升趋势，那么可以认为存在内存泄漏</li> <li>某次快照后，看当前内存占用的趋势图，如果走势不平稳，呈上升趋势，那么可以认为存在内存泄漏
在服务器环境中使用 Node 提供的 <strong>process.memoryUsage</strong> 方法查看内存情况</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { </span>
<span class="token comment">//     rss: 27709440,</span>
<span class="token comment">//     heapTotal: 5685248,</span>
<span class="token comment">//     heapUsed: 3449392,</span>
<span class="token comment">//     external: 8772 </span>
<span class="token comment">// }</span>
</code></pre></div><p><strong>process.memoryUsage</strong>返回一个对象，包含了<strong>Node</strong>进程的内存占用信息。</p> <p>该对象包含四个字段，单位是字节，含义如下:</p> <ul><li><strong>rss（resident set size）</strong>：所有内存占用，包括指令区和堆栈。</li> <li><strong>heapTotal</strong>：&quot;堆&quot;占用的内存，包括用到的和没用到的。</li> <li><strong>heapUsed</strong>：用到的堆的部分。</li> <li><strong>external</strong>： V8 引擎内部的 C++ 对象占用的内存。</li></ul> <p>判断内存泄漏，以<strong>heapUsed</strong>字段为准。</p> <h2 id="常见的内存泄露案例"><a href="#常见的内存泄露案例" class="header-anchor">#</a> 常见的内存泄露案例</h2> <ul><li><code>意外的全局变量</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bar1 <span class="token operator">=</span> <span class="token string">'some text'</span><span class="token punctuation">;</span> <span class="token comment">// 没有声明变量 实际上是全局变量 =&gt; window.bar1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>bar2 <span class="token operator">=</span> <span class="token string">'some text'</span> <span class="token comment">// 全局变量 =&gt; window.bar2</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在这个例子中，意外的创建了两个全局变量 <code>bar1</code> 和 <code>bar2</code></p> <ul><li><code>被遗忘的定时器和回调函数</code></li></ul> <p>在很多库中, 如果使用了观察者模式, 都会提供回调方法, 来调用一些回调函数。 <code>要记得回收这些回调函数</code>。举一个<strong>setInterval</strong>的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> serverData <span class="token operator">=</span> <span class="token function">loadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> renderer <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'renderer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>renderer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        renderer<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>serverData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每 5 秒调用一次</span>
</code></pre></div><p>如果后续<strong>renderer</strong>元素被移除，整个定时器实际上没有任何作用。 但如果你没有回收定时器，整个定时器依然有效, 不但定时器无法被内存回收， 定时器函数中的依赖也无法回收。在这个案例中的 serverData 也无法被回收。</p> <ul><li><code>闭包</code></li></ul> <p>在<strong>JS</strong>开发中，我们会经常用到闭包，<strong>一个内部函数，有权访问包含其的外部函数中的变量</strong>。 下面这种情况下，闭包也会造成内存泄露:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> theThing <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">replaceThing</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> originalThing <span class="token operator">=</span> theThing<span class="token punctuation">;</span>
  <span class="token keyword">var</span> <span class="token function-variable function">unused</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>originalThing<span class="token punctuation">)</span> <span class="token comment">// 对于 'originalThing'的引用</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  theThing <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">longStr</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function-variable function">someMethod</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span>replaceThing<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码，每次调用 <strong>replaceThing</strong> 时，**theThing **获得了包含<code>一个巨大的数组和一个对于新闭包 someMethod 的对象。 同时 unused 是一个引用了 originalThing 的闭包</code>。</p> <p>这个范例的关键在于，<code>闭包之间是共享作用域的，尽管 unused 可能一直没有被调用，但是 someMethod 可能会被调用，就会导致无法对其内存进行回收。 当这段代码被反复执行时，内存会持续增长</code>。</p> <ul><li><code>DOM 引用</code>
很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> elements <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">image</span><span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'image'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    elements<span class="token punctuation">.</span>image<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://example.com/image_name.png'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">removeImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'image'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上述案例中，即使我们对于<strong>image</strong>元素进行了移除，但是仍然有对 <strong>image</strong> 元素的引用，依然无法对齐进行内存回收。</p> <p>另外需要注意的一个点是，对于一个<strong>Dom</strong>树的叶子节点的引用。 举个例子: 如果我们引用了一个表格中的td元素，一旦在<strong>Dom</strong>中删除了整个表格，我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素。 但是事实上，这个 td 元素是整个表格的一个子元素，并保留对于其父元素的引用。 这就会导致对于整个表格，都无法进行内存回收。所以我们要小心处理对于<strong>Dom</strong>元素的引用。</p> <h2 id="排查javascript内存泄漏"><a href="#排查javascript内存泄漏" class="header-anchor">#</a> 排查Javascript内存泄漏</h2> <p><a href="https://zhuanlan.zhihu.com/p/322356761" target="_blank" rel="noopener noreferrer">这里有篇不错的文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>;</p> <p><p data-v-0cb7829d>
    非经营性网站备案信息 <a href="https://beian.miit.gov.cn" target="_blank" data-v-0cb7829d>蜀ICP备2022003521号-1</a></p></p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/javascript/extend/fetch.html" class="prev">
          Fetch
        </a></span> <span class="next"><a href="/blog/javascript/extend/monitoring.html">
          前端监控
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="blog/assets/js/app.24b47bb2.js" defer></script><script src="blog/assets/js/58.4128750e.js" defer></script><script src="blog/assets/js/8.7f11c8af.js" defer></script>
  </body>
</html>
